from io import StringIO, TextIOWrapper
from types import ModuleType
from typing import (IO, TYPE_CHECKING, Any, ByteString, Callable, Dict,
                    Generator, Iterator, List, Literal, Optional, Pattern,
                    Sequence, Tuple, Type, Union)

from typing_extensions import Self

if TYPE_CHECKING:
    import abc
    import enum
    import pathlib

    from . import gdb

GDB_MIN_VERSION: Tuple[int, int] = ...
GDB_VERSION: Tuple[int, int] = ...
PYTHON_MIN_VERSION: Tuple[int, int] = ...
PYTHON_VERSION: Tuple[int, int] = ...

DEFAULT_PAGE_ALIGN_SHIFT: int = ...
DEFAULT_PAGE_SIZE: int = ...

GEF_RC: pathlib.Path = ...
GEF_TEMP_DIR: str = ...
GEF_MAX_STRING_LENGTH: int = ...

LIBC_HEAP_MAIN_ARENA_DEFAULT_NAME: str = ...
ANSI_SPLIT_RE: Literal = ...

LEFT_ARROW: str = ...
RIGHT_ARROW: str = ...
DOWN_ARROW: str = ...
HORIZONTAL_LINE: str = ...
VERTICAL_LINE: str = ...
CROSS: str = ...
TICK: str = ...
BP_GLYPH: str = ...
GEF_PROMPT: str = ...
GEF_PROMPT_ON: str = ...
GEF_PROMPT_OFF: str = ...

PATTERN_LIBC_VERSION: Pattern[bytes] = ...

GEF_DEFAULT_BRANCH: str = ...
GEF_EXTRAS_DEFAULT_BRANCH: str = ...


def http_get(url: str) -> Optional[bytes]: ...
def update_gef(argv: List[str]) -> int: ...
def reset_all_caches() -> None: ...
def reset() -> None: ...
def highlight_text(text: str) -> str: ...
def gef_print(*args: str, end="\\\\\\\\n", sep=" ", **kwargs: Any) -> None: ...
def bufferize(f: Callable) -> Callable: ...
def p8(x: int, s: bool = False) -> bytes: ...
def p16(x: int, s: bool = False) -> bytes: ...
def p32(x: int, s: bool = False) -> bytes: ...
def p64(x: int, s: bool = False) -> bytes: ...
def u8(x: bytes, s: bool = False) -> int: ...
def u16(x: bytes, s: bool = False) -> int: ...
def u32(x: bytes, s: bool = False) -> int: ...
def u64(x: bytes, s: bool = False) -> int: ...
def is_ascii_string(address: int) -> bool: ...
def is_alive() -> bool: ...
def only_if_gdb_running(f: Callable) -> Callable: ...
def only_if_gdb_target_local(f: Callable) -> Callable: ...
def deprecated(solution: str = "") -> Callable: ...
def experimental_feature(f: Callable) -> Callable: ...
def only_if_events_supported(event_type: str) -> Callable: ...


class classproperty(property):
    def __get__(self, cls, owner): ...


def FakeExit(*args: Any, **kwargs: Any) -> None: ...


def parse_arguments(required_arguments: Dict[Union[str, Tuple[str, str]], Any],
                    optional_arguments: Dict[Union[str, Tuple[str, str]], Any]) -> Callable: ...


class Color:
    @staticmethod
    def redify(msg: str) -> str:        ...
    @staticmethod
    def greenify(msg: str) -> str:      ...
    @staticmethod
    def blueify(msg: str) -> str:       ...
    @staticmethod
    def yellowify(msg: str) -> str:     ...
    @staticmethod
    def grayify(msg: str) -> str:       ...
    @staticmethod
    def light_grayify(msg: str) -> str: ...
    @staticmethod
    def pinkify(msg: str) -> str:       ...
    @staticmethod
    def cyanify(msg: str) -> str:       ...
    @staticmethod
    def boldify(msg: str) -> str:       ...
    @staticmethod
    def underlinify(msg: str) -> str:   ...
    @staticmethod
    def highlightify(msg: str) -> str:  ...
    @staticmethod
    def blinkify(msg: str) -> str:      ...
    @staticmethod
    def colorify(text: str, attrs: str) -> str: ...


class Address:
    value: int = ...
    section: Section = ...
    info: Zone = ...
    def __init__(self, **kwargs: Any) -> None: ...
    def __str__(self) -> str: ...
    def __int__(self) -> int: ...
    def is_in_text_segment(self) -> bool: ...
    def is_in_stack_segment(self) -> bool: ...
    def is_in_heap_segment(self) -> bool: ...
    def dereference(self) -> Optional[int]: ...
    def valid(self) -> bool: ...


class Permission(enum.Flag):
    NONE: int
    EXECUTE: int
    WRITE: int
    READ: int
    ALL: int
    def __str__(self) -> str: ...
    @staticmethod
    def from_info_sections(*args: str) -> "Permission": ...
    @staticmethod
    def from_process_maps(perm_str: str) -> "Permission": ...


class Section:
    page_start: int
    page_end: int
    offset: int
    permission: Permission
    inode: int
    path: str
    def __init__(self, **kwargs: Any) -> None: ...
    def is_readable(self) -> bool: ...
    def is_writable(self) -> bool: ...
    def is_executable(self) -> bool: ...
    @property
    def size(self) -> int: ...
    @property
    def realpath(self) -> str: ...
    def __str__(self) -> str: ...


class Endianness(enum.Enum):
    LITTLE_ENDIAN: int
    BIG_ENDIAN: int
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def __int__(self) -> int: ...


class Elf:
    ELF_MAGIC: int

    class Class(enum.Enum):
        ELF_32_BITS = 0x01
        ELF_64_BITS = 0x02

    class Abi(enum.Enum):
        X86_64: int
        X86_32: int
        ARM: int
        MIPS: int
        POWERPC: int
        POWERPC64: int
        SPARC: int
        SPARC64: int
        AARCH64: int
        RISCV: int
        IA64: int
        M68K: int

    class Type(enum.Enum):
        ET_RELOC: int
        ET_EXEC: int
        ET_DYN: int
        ET_CORE: int

    class OsAbi(enum.Enum):
        SYSTEMV: int
        HPUX: int
        NETBSD: int
        LINUX: int
        SOLARIS: int
        AIX: int
        IRIX: int
        FREEBSD: int
        OPENBSD: int

    e_magic: int
    e_class: Elf.Class
    e_endianness: Endianness
    e_eiversion: int
    e_osabi: Elf.OsAbi
    e_abiversion: int
    e_pad: bytes
    e_type: Elf.Type
    e_machine: Abi
    e_version: int
    e_entry: int
    e_phoff: int
    e_shoff: int
    e_flags: int
    e_ehsize: int
    e_phentsize: int
    e_phnum: int
    e_shentsize: int
    e_shnum: int
    e_shstrndx: int

    def __init__(self, path: str = "", minimalist: bool = False) -> None: ...
    def read(self, size: int) -> bytes: ...
    def read_and_unpack(self, fmt: str) -> Tuple[Any, ...]: ...
    def seek(self, off: int) -> None: ...
    def __str__(self) -> str: ...
    def entry_point(self) -> int: ...
    @classmethod
    def X86_64(cls) -> int: ...
    @classmethod
    def X86_32(cls) -> int: ...
    @classmethod
    def ARM(cls) -> int: ...
    @classmethod
    def MIPS(cls) -> int: ...
    @classmethod
    def POWERPC(cls) -> int: ...
    @classmethod
    def POWERPC64(cls) -> int: ...
    @classmethod
    def SPARC(cls) -> int: ...
    @classmethod
    def SPARC64(cls) -> int: ...
    @classmethod
    def AARCH64(cls) -> int: ...
    @classmethod
    def RISCV(cls) -> int: ...


class Phdr:
    class Type(enum.IntEnum):
        @classmethod
        def _missing_(cls, _: int) -> Type: ...

    class Flags(enum.IntFlag):
        ...

    def __init__(self, elf: Elf, off: int) -> None: ...
    def __str__(self) -> str: ...


class Shdr:
    class Type(enum.IntEnum):
        @classmethod
        def _missing_(cls, _: int) -> Type: ...

    class Flags(enum.IntFlag):
        @classmethod
        def _missing_(cls, _: int): ...

    def __init__(self, elf: Optional[Elf], off: int) -> None: ...
    def __str__(self) -> str: ...


class Instruction:
    address: int
    location: int
    mnemonic: str
    operands: List[str]
    opcodes: bytes
    def __init__(self, address: int, location: str, mnemo: str,
                 operands: List[str], opcodes: bytes) -> None: ...

    def __format__(self, format_spec: str) -> str: ...
    def __str__(self) -> str: ...
    def is_valid(self) -> bool: ...
    def size(self) -> int: ...


def search_for_main_arena() -> int: ...


class MallocStateStruct:
    def __init__(self, addr: str) -> None: ...
    def addr(self) -> int: ...
    def fastbins_addr(self) -> int: ...
    def top_addr(self) -> int: ...
    def last_remainder_addr(self) -> int: ...
    def bins_addr(self) -> int: ...
    def next_addr(self) -> int: ...
    def next_free_addr(self) -> int: ...
    def system_mem_addr(self) -> int: ...
    def struct_size(self) -> int: ...
    def fastbinsY(self) -> gdb.Value: ...
    def top(self) -> "gdb.Value": ...
    def last_remainder(self) -> "gdb.Value": ...
    def bins(self) -> "gdb.Value": ...
    def next(self) -> "gdb.Value": ...
    def next_free(self) -> "gdb.Value": ...
    def system_mem(self) -> "gdb.Value": ...
    def get_size_t(self, addr: int) -> "gdb.Value": ...
    def get_size_t_pointer(self, addr: int) -> "gdb.Value": ...
    def get_size_t_array(self, addr: int, length: int) -> "gdb.Value": ...
    def __getitem__(self, item: str) -> Any: ...


class GlibcHeapInfo:
    def __init__(self, addr: Union[int, str]) -> None: ...
    def addr(self) -> int: ...
    def ar_ptr_addr(self) -> int: ...
    def prev_addr(self) -> int: ...
    def size_addr(self) -> int: ...
    def mprotect_size_addr(self) -> int: ...
    def ar_ptr(self) -> "gdb.Value": ...
    def prev(self) -> "gdb.Value": ...
    def size(self) -> "gdb.Value": ...
    def mprotect_size(self) -> "gdb.Value": ...
    def _get_size_t_pointer(self, addr: int) -> "gdb.Value": ...
    def _get_size_t(self, addr: int) -> "gdb.Value": ...


class GlibcArena:
    def __init__(self, addr: str) -> None: ...
    def __getitem__(self, item: Any) -> Any: ...
    def __getattr__(self, item: Any) -> Any: ...
    def __int__(self) -> int: ...
    def __iter__(self) -> Generator[Self, None, None]: ...
    def __eq__(self, other: "GlibcArena") -> bool: ...
    def fastbin(self, i: int) -> Optional["GlibcChunk"]: ...
    def bin(self, i: int) -> Tuple[int, int]: ...
    def is_main_arena(self) -> bool: ...
    def heap_addr(self, allow_unaligned: bool = False) -> Optional[int]: ...
    def get_heap_info_list(self) -> Optional[List[GlibcHeapInfo]]: ...
    @staticmethod
    def get_heap_for_ptr(ptr: int) -> int: ...
    def __str__(self) -> str: ...
    def addr(self) -> int: ...


class GlibcChunk:
    base_address: int
    data_address: int
    size_addr: int
    prev_size_addr: int
    def __init__(self, addr: int, from_base: bool = False,
                 allow_unaligned: bool = True) -> None: ...

    def get_chunk_size(self) -> int: ...
    @property
    def size(self) -> int: ...
    def get_usable_size(self) -> int: ...
    def usable_size(self) -> int: ...
    def get_prev_chunk_size(self) -> int: ...
    def __iter__(self) -> Generator["GlibcChunk", None, None]: ...
    def get_next_chunk(
        self, allow_unaligned: bool = False) -> "GlibcChunk": ...

    def get_next_chunk_addr(self) -> int: ...
    def get_fwd_ptr(self, sll: bool) -> int: ...
    @property
    def fwd(self) -> int: ...
    def get_bkw_ptr(self) -> int: ...
    @property
    def bck(self) -> int: ...
    def has_p_bit(self) -> bool: ...
    def has_m_bit(self) -> bool: ...
    def has_n_bit(self) -> bool: ...
    def is_used(self) -> bool: ...
    def str_chunk_size_flag(self) -> str: ...
    def _str_sizes(self) -> str: ...
    def _str_pointers(self) -> str: ...
    def str_as_alloced(self) -> str: ...
    def str_as_freed(self) -> str: ...
    def flags_as_string(self) -> str: ...
    def __str__(self) -> str: ...
    def psprint(self) -> str: ...


def get_libc_version() -> Tuple[int, ...]: ...
def titlify(text: str, color: Optional[str] = None,
            msg_color: Optional[str] = None) -> str: ...


def err(msg: str) -> None: ...
def warn(msg: str) -> None: ...
def ok(msg: str) -> None: ...
def info(msg: str) -> None: ...
def push_context_message(level: str, message: str) -> None: ...


def show_last_exception() -> None:
    def _show_code_line(fname: str, idx: int) -> str: ...


def gef_pystring(x: bytes) -> str: ...
def gef_pybytes(x: str) -> bytes: ...
def which(program: str) -> pathlib.Path: ...
def style_byte(b: int, color: bool = True) -> str: ...
def hexdump(source: ByteString, length: int = 0x10, separator: str = ".",
            show_raw: bool = False, show_symbol: bool = True, base: int = 0x00) -> str: ...


def is_debug() -> bool: ...
def hide_context() -> bool: ...
def unhide_context() -> bool: ...


class RedirectOutputContext():
    def __init__(self, to: str = "/dev/null") -> None: ...
    def __enter__(self) -> None: ...
    def __exit__(self, *exc: Any) -> None: ...


def enable_redirect_output(to_file: str = "/dev/null") -> None: ...
def disable_redirect_output() -> None: ...
def gef_makedirs(path: str, mode: int = 0o755) -> pathlib.Path: ...


def gdb_lookup_symbol(sym: str) -> Optional[Tuple[Optional[str],
                                                  Optional[Tuple[gdb.Symtab_and_line, ...]]]]: ...


def gdb_get_location_from_symbol(
    address: int) -> Optional[Tuple[str, int]]: ...


def gdb_disassemble(
    start_pc: int, **kwargs: int) -> Generator[Instruction, None, None]: ...
def gdb_get_nth_previous_instruction_address(
    addr: int, n: int) -> Optional[int]: ...


def gdb_get_nth_next_instruction_address(addr: int, n: int) -> int: ...
def gef_instruction_n(addr: int, n: int) -> Instruction: ...
def gef_get_instruction_at(addr: int) -> Instruction: ...
def gef_current_instruction(addr: int) -> Instruction: ...
def gef_next_instruction(addr: int) -> Instruction: ...


def gef_disassemble(addr: int, nb_insn: int,
                    nb_prev: int = 0) -> Generator[Instruction, None, None]: ...


def gef_execute_external(
    command: Sequence[str], as_list: bool = False, **kwargs: Any) -> Union[str, List[str]]: ...


def gef_execute_gdb_script(commands: str) -> None: ...


def checksec(filename: str) -> Dict[str, bool]:
    def __check_security_property(
        opt: str, filename: str, pattern: str) -> bool: ...


def get_arch() -> str: ...
def get_entry_point() -> Optional[int]: ...
def is_pie(fpath: str) -> bool: ...
def is_big_endian() -> bool: ...
def is_little_endian() -> bool: ...
def flags_to_human(reg_value: int, value_table: Dict[int, str]) -> str: ...
def get_section_base_address(name: str) -> Optional[int]: ...
def get_zone_base_address(name: str) -> Optional[int]: ...


def register_architecture(
    cls: Type["Architecture"]) -> Type["Architecture"]: ...


class ArchitectureBase:
    def __init_subclass__(cls: Type["ArchitectureBase"], **kwargs): ...


class Architecture(ArchitectureBase):
    arch: str
    mode: str
    all_registers: Union[Tuple[()], Tuple[str, ...]]
    nop_insn: bytes
    return_register: str
    flag_register: Optional[str]
    instruction_length: Optional[int]
    flags_table: Dict[int, str]
    syscall_register: Optional[str]
    syscall_instructions: Union[Tuple[()], Tuple[str, ...]]
    function_parameters: Union[Tuple[()], Tuple[str, ...]]

    def __init_subclass__(cls, **kwargs): ...
    @staticmethod
    def supports_gdb_arch(gdb_arch: str) -> Optional[bool]: ...
    def flag_register_to_human(self, val: Optional[int] = None) -> str: ...
    def is_call(self, insn: Instruction) -> bool: ...
    def is_ret(self, insn: Instruction) -> bool: ...
    def is_conditional_branch(self, insn: Instruction) -> bool: ...
    def is_branch_taken(self, insn: Instruction) -> Tuple[bool, str]: ...
    def get_ra(self, insn: Instruction,
               frame: "gdb.Frame") -> Optional[int]: ...

    @classmethod
    def mprotect_asm(cls, addr: int, size: int, perm: Permission) -> str: ...
    def reset_caches(self) -> None: ...
    def __get_register(self, regname: str) -> int: ...
    def __get_register_for_selected_frame(
        self, regname: str, hash_key: int) -> int: ...

    def register(self, name: str) -> int: ...
    @property
    def registers(self) -> Generator[str, None, None]: ...
    @property
    def pc(self) -> int: ...
    @property
    def sp(self) -> int: ...
    @property
    def fp(self) -> int: ...
    @property
    def ptrsize(self) -> int: ...
    @property
    def endianness(self) -> Endianness: ...
    def get_ith_parameter(
        self, i: int, in_func: bool = True) -> Tuple[str, Optional[int]]: ...


class GenericArchitecture(Architecture):
    ...


class RISCV(Architecture):
    def instruction_length(self) -> int: ...
    def is_call(self, insn: Instruction) -> bool: ...
    def is_ret(self, insn: Instruction) -> bool: ...
    @classmethod
    def mprotect_asm(cls, addr: int, size: int, perm: Permission) -> str: ...
    def ptrsize(self) -> int: ...
    def is_conditional_branch(self, insn: Instruction) -> bool: ...

    def is_branch_taken(self, insn: Instruction) -> Tuple[bool, str]:
        def long_to_twos_complement(v: int) -> int: ...

    def get_ra(self, insn: Instruction,
               frame: "gdb.Frame") -> Optional[int]: ...


class ARM(Architecture):
    def is_thumb(self) -> bool: ...
    def pc(self) -> Optional[int]: ...
    def mode(self) -> str: ...
    def instruction_length(self) -> Optional[int]: ...
    def ptrsize(self) -> int: ...
    def is_call(self, insn: Instruction) -> bool: ...
    def is_ret(self, insn: Instruction) -> bool: ...
    def flag_register_to_human(self, val: Optional[int] = None) -> str: ...
    def is_conditional_branch(self, insn: Instruction) -> bool: ...
    def is_branch_taken(self, insn: Instruction) -> Tuple[bool, str]: ...
    def get_ra(self, insn: Instruction, frame: "gdb.Frame") -> int: ...
    @classmethod
    def mprotect_asm(cls, addr: int, size: int, perm: Permission) -> str: ...


class AARCH64(ARM):
    def is_call(self, insn: Instruction) -> bool: ...
    def flag_register_to_human(self, val: Optional[int] = None) -> str: ...
    @classmethod
    def mprotect_asm(cls, addr: int, size: int, perm: Permission) -> str: ...
    def is_conditional_branch(self, insn: Instruction) -> bool: ...
    def is_branch_taken(self, insn: Instruction) -> Tuple[bool, str]: ...


class X86(Architecture):
    def flag_register_to_human(self, val: Optional[int] = None) -> str: ...
    def is_call(self, insn: Instruction) -> bool: ...
    def is_ret(self, insn: Instruction) -> bool: ...
    def is_conditional_branch(self, insn: Instruction) -> bool: ...
    def is_branch_taken(self, insn: Instruction) -> Tuple[bool, str]: ...
    def get_ra(self, insn: Instruction,
               frame: "gdb.Frame") -> Optional[int]: ...

    @classmethod
    def mprotect_asm(cls, addr: int, size: int, perm: Permission) -> str: ...
    def get_ith_parameter(
        self, i: int, in_func: bool = True) -> Tuple[str, Optional[int]]: ...


class X86_64(X86):
    @classmethod
    def mprotect_asm(cls, addr: int, size: int, perm: Permission) -> str: ...


class PowerPC(Architecture):
    def flag_register_to_human(self, val: Optional[int] = None) -> str: ...
    def is_call(self, insn: Instruction) -> bool: ...
    def is_ret(self, insn: Instruction) -> bool: ...
    def is_conditional_branch(self, insn: Instruction) -> bool: ...
    def is_branch_taken(self, insn: Instruction) -> Tuple[bool, str]: ...
    def get_ra(self, insn: Instruction,
               frame: "gdb.Frame") -> Optional[int]: ...

    @classmethod
    def mprotect_asm(cls, addr: int, size: int, perm: Permission) -> str: ...


class PowerPC64(PowerPC):
    ...


class SPARC(Architecture):
    def flag_register_to_human(self, val: Optional[int] = None) -> str: ...
    def is_call(self, insn: Instruction) -> bool: ...
    def is_ret(self, insn: Instruction) -> bool: ...
    def is_conditional_branch(self, insn: Instruction) -> bool: ...
    def is_branch_taken(self, insn: Instruction) -> Tuple[bool, str]: ...
    def get_ra(self, insn: Instruction,
               frame: "gdb.Frame") -> Optional[int]: ...

    @classmethod
    def mprotect_asm(cls, addr: int, size: int, perm: Permission) -> str: ...


class SPARC64(SPARC):
    @classmethod
    def mprotect_asm(cls, addr: int, size: int, perm: Permission) -> str: ...


class MIPS(Architecture):
    def flag_register_to_human(self, val: Optional[int] = None) -> str: ...
    def is_call(self, insn: Instruction) -> bool: ...
    def is_ret(self, insn: Instruction) -> bool: ...
    def is_conditional_branch(self, insn: Instruction) -> bool: ...
    def is_branch_taken(self, insn: Instruction) -> Tuple[bool, str]: ...
    def get_ra(self, insn: Instruction,
               frame: "gdb.Frame") -> Optional[int]: ...

    @classmethod
    def mprotect_asm(cls, addr: int, size: int, perm: Permission) -> str: ...


class MIPS64(MIPS):
    @staticmethod
    def supports_gdb_arch(gdb_arch: str) -> Optional[bool]: ...


class Zone:
    ...


def copy_to_clipboard(data: bytes) -> None: ...
def use_stdtype() -> str: ...
def use_default_type() -> str: ...
def use_golang_type() -> str: ...
def use_rust_type() -> str: ...
def to_unsigned_long(v: gdb.Value) -> int: ...
def get_path_from_info_proc() -> Optional[str]: ...
def get_os() -> str: ...
def is_qemu() -> bool: ...
def is_qemu_usermode() -> bool: ...
def is_qemu_system() -> bool: ...
def get_filepath() -> Optional[str]: ...
def download_file(remote_path: str, use_cache: bool = False,
                  local_name: Optional[str] = None) -> Optional[str]: ...


def get_function_length(sym: str) -> int: ...
def get_info_files() -> List[Zone]: ...
def process_lookup_address(address: int) -> Optional[Section]: ...
def process_lookup_path(
    name: str, perm: Permission = Permission.ALL) -> Optional[Section]: ...  # type: ignore


def file_lookup_name_path(name: str, path: str) -> Optional[Zone]: ...
def file_lookup_address(address: int) -> Optional[Zone]: ...
def lookup_address(address: int) -> Address: ...
def xor(data: ByteString, key: str) -> bytearray: ...
def is_hex(pattern: str) -> bool: ...
def continue_handler(_: gdb.Event) -> None: ...
def hook_stop_handler(_: gdb.Event) -> None: ...
def new_objfile_handler(_: gdb.Event) -> None: ...
def exit_handler(_: gdb.Event) -> None: ...
def memchanged_handler(_: gdb.Event) -> None: ...
def regchanged_handler(_: gdb.Event) -> None: ...
def load_libc_args() -> bool: ...
def get_terminal_size() -> Tuple[int, int]: ...


def get_elf_headers(filename: Optional[str] = None) -> Elf: ...
def is_64bit() -> bool: ...
def is_32bit() -> bool: ...
def is_x86_64() -> bool: ...
def is_x86_32(): ...
def is_x86() -> bool: ...
def is_arch(arch: Elf.Abi) -> bool: ...
def reset_architecture(arch: Optional[str] = None) -> None: ...
def cached_lookup_type(_type: str) -> Optional[gdb.Type]: ...
def get_memory_alignment(in_bits: bool = False) -> int: ...
def clear_screen(tty: str = "") -> None: ...
def format_address(addr: int) -> str: ...
def format_address_spaces(addr: int, left: bool = True) -> str: ...
def align_address(address: int) -> int: ...
def align_address_to_size(address: int, align: int) -> int: ...
def align_address_to_page(address: int) -> int: ...
def parse_address(address: str) -> int: ...
def is_in_x86_kernel(address: int) -> bool: ...
def is_remote_debug() -> bool: ...


def de_bruijn(alphabet: bytes, n: int) -> Generator[str, None, None]:
    def db(t: int, p: int) -> Generator[str, None, None]: ...


def generate_cyclic_pattern(length: int, cycle: int = 4) -> bytearray: ...
def safe_parse_and_eval(value: str) -> Optional["gdb.Value"]: ...
def dereference(addr: int) -> Optional["gdb.Value"]: ...
def gef_convenience(value: str) -> str: ...
def parse_string_range(s: str) -> Iterator[int]: ...
def is_syscall(instruction: Union[Instruction, int]) -> bool: ...
def gef_get_pie_breakpoint(num: int) -> "PieVirtualBreakpoint": ...
def endian_str() -> str: ...


def gef_on_continue_hook(func: Callable[[gdb.Event], None]) -> None: ...
def gef_on_continue_unhook(func: Callable[[gdb.Event], None]) -> None: ...
def gef_on_stop_hook(func: Callable[[gdb.Event], None]) -> None: ...
def gef_on_stop_unhook(func: Callable[[gdb.Event], None]) -> None: ...
def gef_on_exit_hook(func: Callable[[gdb.Event], None]) -> None: ...
def gef_on_exit_unhook(func: Callable[[gdb.Event], None]) -> None: ...
def gef_on_new_hook(func: Callable[[gdb.Event], None]) -> None: ...
def gef_on_new_unhook(func: Callable[[gdb.Event], None]) -> None: ...
def gef_on_memchanged_hook(func: Callable[[gdb.Event], None]) -> None: ...
def gef_on_memchanged_unhook(func: Callable[[gdb.Event], None]) -> None: ...
def gef_on_regchanged_hook(func: Callable[[gdb.Event], None]) -> None: ...
def gef_on_regchanged_unhook(func: Callable[[gdb.Event], None]) -> None: ...


class PieVirtualBreakpoint:
    def __init__(self, set_func: Callable[[
                 int], str], vbp_num: int, addr: int) -> None: ...

    def instantiate(self, base: int) -> None: ...
    def destroy(self) -> None: ...


class FormatStringBreakpoint(gdb.Breakpoint):
    def __init__(self, spec: str, num_args: int) -> None: ...
    def stop(self) -> bool: ...


class StubBreakpoint(gdb.Breakpoint):
    def __init__(self, func: str, retval: Optional[int]) -> None: ...
    def stop(self) -> bool: ...


class ChangePermissionBreakpoint(gdb.Breakpoint):
    def __init__(self, loc: str, code: ByteString, pc: int) -> None: ...
    def stop(self) -> bool: ...


class TraceMallocBreakpoint(gdb.Breakpoint):
    def __init__(self, name: str) -> None: ...
    def stop(self) -> bool: ...


class TraceMallocRetBreakpoint(gdb.FinishBreakpoint):
    def __init__(self, size: int, name: str) -> None: ...
    def stop(self) -> bool: ...


class TraceReallocBreakpoint(gdb.Breakpoint):
    def __init__(self) -> None: ...
    def stop(self) -> bool: ...


class TraceReallocRetBreakpoint(gdb.FinishBreakpoint):
    def __init__(self, ptr: int, size: int) -> None: ...
    def stop(self) -> bool: ...


class TraceFreeBreakpoint(gdb.Breakpoint):
    def __init__(self) -> None: ...
    def stop(self) -> bool: ...


class TraceFreeRetBreakpoint(gdb.FinishBreakpoint):
    def __init__(self, addr: int) -> None: ...
    def stop(self) -> bool: ...


class UafWatchpoint(gdb.Breakpoint):
    def __init__(self, addr: int) -> None: ...
    def stop(self) -> bool: ...


class EntryBreakBreakpoint(gdb.Breakpoint):
    def __init__(self, location: str) -> None: ...
    def stop(self) -> bool: ...


class NamedBreakpoint(gdb.Breakpoint):
    def __init__(self, location: str, name: str) -> None: ...
    def stop(self) -> bool: ...


def register_external_context_pane(pane_name: str, display_pane_function: Callable[[], None], pane_title_function: Callable[[], Optional[str]], condition: Optional[Callable[[], bool]]) -> None:
    def display_pane() -> None:  ...
    def pane_title() -> str:  ...


def register_external_context_layout_mapping(current_pane_name: str, display_pane_function: Callable[[], None], pane_title_function: Callable[[], Optional[str]], condition: Optional[Callable[[], bool]]) -> None:
    def display_pane() -> None:  ...
    def pane_title() -> str:  ...


def register(cls: Union[Type["GenericCommand"], Type["GenericFunction"]]) -> Union[Type["GenericCommand"], Type["GenericFunction"]]: ...


class GenericCommandBase:
    def __init_subclass__(cls: Type["GenericCommandBase"], **kwargs): ...


class GenericExternalCommandBase(GenericCommandBase):
    def __init_subclass__(
        cls: Type["GenericExternalCommandBase"], **kwargs): ...


class GenericCommand(gdb.Command, GenericCommandBase):
    def __init_subclass__(cls, **kwargs): ...
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    def invoke(self, args: str, from_tty: bool) -> None: ...
    def usage(self) -> None: ...
    def do_invoke(self, argv: List[str]) -> None: ...
    def pre_load(self) -> None: ...
    def post_load(self) -> None: ...
    def __get_setting_name(self, name: str) -> str: ...
    def __iter__(self) -> Generator[str, None, None]: ...
    def settings(self) -> List[str]: ...
    def get_setting(self, name: str) -> Any: ...
    def __getitem__(self, name: str) -> Any: ...
    def has_setting(self, name: str) -> bool: ...
    def __contains__(self, name: str) -> bool: ...

    def add_setting(
        self, name: str, value: Tuple[Any, type, str], description: str = "") -> None: ...
    def __setitem__(self, name: str,
                    value: Union[Any, Tuple[Any, str]]) -> None: ...

    def del_setting(self, name: str) -> None: ...
    def __delitem__(self, name: str) -> None: ...
    def __set_repeat_count(self, argv: List[str], from_tty: bool) -> None: ...


class VersionCommand(GenericCommand):
    def do_invoke(self, argv: List[str]) -> None: ...


class PrintFormatCommand(GenericCommand):
    def __init__(self) -> None: ...
    def format_matrix(self) -> Dict[int, Tuple[str, str, str]]: ...
    def do_invoke(self, _: List[str], **kwargs: Any) -> None: ...


class PieCommand(GenericCommand):
    def __init__(self) -> None: ...
    def do_invoke(self, argv: List[str]) -> None: ...


class PieBreakpointCommand(GenericCommand):
    def do_invoke(self, _: List[str], **kwargs: Any) -> None: ...

    @staticmethod
    def set_pie_breakpoint(
        set_func: Callable[[int], str], addr: int) -> None: ...


class PieInfoCommand(GenericCommand):
    def do_invoke(self, _: List[str], **kwargs: Any) -> None: ...


class PieDeleteCommand(GenericCommand):
    def do_invoke(self, _: List[str], **kwargs: Any) -> None: ...
    @staticmethod
    def delete_bp(breakpoints: List[PieVirtualBreakpoint]) -> None: ...


class PieRunCommand(GenericCommand):
    def do_invoke(self, argv: List[str]) -> None: ...


class PieAttachCommand(GenericCommand):
    def do_invoke(self, argv: List[str]) -> None: ...


class PieRemoteCommand(GenericCommand):
    def do_invoke(self, argv: List[str]) -> None: ...


class SmartEvalCommand(GenericCommand):
    def do_invoke(self, argv: List[str]) -> None: ...

    def evaluate(self, expr: List[str]) -> None:
        def show_as_int(i: int) -> None:
            def comp2_x(x: Any) -> str: ...
            def comp2_b(x: Any) -> str: ...

    def distance(self, args: Tuple[str, str]) -> None: ...


class CanaryCommand(GenericCommand):
    def do_invoke(self, argv: List[str]) -> None: ...


class ProcessStatusCommand(GenericCommand):
    def __init__(self) -> None: ...
    def do_invoke(self, argv: List[str]) -> None: ...
    def get_state_of(self, pid: int) -> Dict[str, str]: ...
    def get_cmdline_of(self, pid: int) -> str: ...
    def get_process_path_of(self, pid: int) -> str: ...
    def get_children_pids(self, pid: int) -> List[int]: ...
    def show_info_proc(self) -> None: ...
    def show_ancestor(self) -> None: ...
    def show_descendants(self) -> None: ...
    def show_fds(self) -> None: ...
    def list_sockets(self, pid: int) -> List[int]: ...
    def parse_ip_port(self, addr: str) -> Tuple[str, int]: ...
    def show_connections(self) -> None: ...


class GefThemeCommand(GenericCommand):
    def __init__(self) -> None: ...
    def do_invoke(self, args: List[str]) -> None: ...


class ExternalStructureManager:
    class Structure:
        def __init__(self, manager: "ExternalStructureManager",
                     mod_path: pathlib.Path, struct_name: str) -> None: ...

        def __str__(self) -> str: ...
        def pprint(self) -> None: ...
        def __get_structure_class(self) -> Type: ...
        def apply_at(self, address: int, max_depth: int,
                     depth: int = 0) -> None: ...

        def __get_ctypes_value(self, struct, item, value) -> str: ...

    class Module(dict):
        def __init__(self, manager: "ExternalStructureManager",
                     path: pathlib.Path) -> None: ...

        def __load(self) -> ModuleType: ...
        def __str__(self) -> str: ...
        def __iter__(self) -> Generator[str, None, None]: ...

    class Modules(dict):
        def __init__(self, manager: "ExternalStructureManager") -> None: ...
        def __contains__(self, structure_name: str) -> bool: ...

    def __init__(self) -> None: ...
    def clear_caches(self) -> None: ...
    def modules(self) -> "ExternalStructureManager.Modules": ...
    def path(self) -> pathlib.Path: ...

    def structures(self) -> Generator[Tuple["ExternalStructureManager.Module",
                                            "ExternalStructureManager.Structure"], None, None]: ...
    def find(self, structure_name: str) -> Optional[Tuple["ExternalStructureManager.Module",
                                                          "ExternalStructureManager.Structure"]]: ...


class PCustomCommand(GenericCommand):
    def __init__(self) -> None: ...
    def do_invoke(self, *_: Any, **kwargs: Dict[str, Any]) -> None: ...
    def explode_type(self, arg: str) -> Tuple[str, str]: ...


class PCustomListCommand(PCustomCommand):
    def __init__(self) -> None: ...
    def do_invoke(self, _: List) -> None: ...


class PCustomShowCommand(PCustomCommand):
    def __init__(self) -> None: ...
    def do_invoke(self, argv: List[str]) -> None: ...


class PCustomEditCommand(PCustomCommand):
    def __init__(self) -> None: ...
    def do_invoke(self, argv: List[str]) -> None: ...

    def __create_or_edit_structure(
        self, mod_name: str, struct_name: str) -> int: ...
    def __create_template(self, structname: str,
                          fpath: pathlib.Path) -> None: ...


class ChangeFdCommand(GenericCommand):
    def do_invoke(self, argv: List[str]) -> None: ...
    def get_fd_from_result(self, res: str) -> int: ...


class IdaInteractCommand(GenericCommand):
    def do_invoke(self, argv: List[str]) -> None: ...


class ScanSectionCommand(GenericCommand):
    def do_invoke(self, argv: List[str]) -> None: ...


class SearchPatternCommand(GenericCommand):
    def print_section(self, section: Section) -> None: ...
    def print_loc(self, loc: Tuple[int, int, str]) -> None: ...
    def search_pattern_by_address(self, pattern: str, start_address: int,
                                  end_address: int) -> List[Tuple[int, int, Optional[str]]]: ...

    def search_pattern(self, pattern: str, section_name: str) -> None: ...
    def do_invoke(self, argv: List[str]) -> None: ...


class FlagsCommand(GenericCommand):
    def do_invoke(self, argv: List[str]) -> None: ...


class ChangePermissionCommand(GenericCommand):
    def __init__(self) -> None: ...
    def pre_load(self) -> None: ...
    def do_invoke(self, argv: List[str]) -> None: ...
    def get_stub_by_arch(self, addr: int, size: int,
                         perm: Permission) -> Union[str, bytearray, None]: ...


class UnicornEmulateCommand(GenericCommand):
    def __init__(self) -> None: ...
    def pre_load(self) -> None: ...
    def do_invoke(self, _: List[str], **kwargs: Any) -> None: ...
    def get_unicorn_end_addr(self, start_addr: int, nb: int) -> int: ...
    def run_unicorn(self, start_insn_addr: int,
                    end_insn_addr: int, **kwargs: Any) -> None: ...


class RemoteCommand(GenericCommand):
    def __init__(self) -> None: ...
    def do_invoke(self, _: List[str], **kwargs: Any) -> None: ...
    def new_objfile_handler(self, event: gdb.Event) -> None: ...

    def setup_remote_environment(
        self, pid: int, update_solib: bool = False) -> None: ...
    def connect_target(self, target: str,
                       is_extended_remote: bool) -> bool: ...

    def load_from_remote_proc(self, pid: int, info: str) -> Optional[str]: ...
    def refresh_shared_library_path(self) -> None: ...
    def usage(self) -> None: ...
    def prepare_qemu_stub(self, target: str) -> None: ...


class NopCommand(GenericCommand):
    def __init__(self) -> None: ...
    def do_invoke(self, _: List[str], **kwargs: Any) -> None: ...


class StubCommand(GenericCommand):
    def __init__(self) -> None: ...
    def do_invoke(self, _: List[str], **kwargs: Any) -> None: ...


class CapstoneDisassembleCommand(GenericCommand):
    def pre_load(self) -> None: ...
    def __init__(self) -> None: ...
    def do_invoke(self, _: List[str], **kwargs: Any) -> None: ...
    def capstone_analyze_pc(self, insn: Instruction,
                            nb_insn: int) -> Tuple[bool, str]: ...


class GlibcHeapCommand(GenericCommand):
    def __init__(self) -> None: ...
    def do_invoke(self, _: List[str]) -> None: ...


class GlibcHeapSetArenaCommand(GenericCommand):
    def __init__(self) -> None: ...
    def do_invoke(self, argv: List[str]) -> None: ...


class GlibcHeapArenaCommand(GenericCommand):
    def do_invoke(self, _: List[str]) -> None: ...


class GlibcHeapChunkCommand(GenericCommand):
    def __init__(self) -> None: ...
    def do_invoke(self, _: List[str], **kwargs: Any) -> None: ...


class GlibcHeapChunksCommand(GenericCommand):
    def __init__(self) -> None: ...
    def do_invoke(self, _: List[str], **kwargs: Any) -> None: ...

    def dump_chunks_arena(self, arena: GlibcArena, print_arena: bool = False,
                          allow_unaligned: bool = False) -> None: ...
    def dump_chunks_heap(self, start: int, until: Optional[int] = None,
                         top: Optional[int] = None, allow_unaligned: bool = False) -> None: ...


class GlibcHeapBinsCommand(GenericCommand):
    def __init__(self) -> None: ...
    def do_invoke(self, argv: List[str]) -> None: ...
    @staticmethod
    def pprint_bin(arena_addr: str, index: int, _type: str = "") -> int: ...


class GlibcHeapTcachebinsCommand(GenericCommand):
    TCACHE_MAX_BINS: int
    def __init__(self) -> None: ...
    def do_invoke(self, argv: List[str]) -> None: ...
    @staticmethod
    def find_tcache() -> int: ...
    @staticmethod
    def check_thread_ids(tids: List[int]) -> List[int]: ...

    @staticmethod
    def tcachebin(tcache_base: int,
                  i: int) -> Tuple[Optional[GlibcChunk], int]: ...


class GlibcHeapFastbinsYCommand(GenericCommand):
    def __init__(self) -> None: ...

    def do_invoke(self, *_: Any, **kwargs: Any) -> None:
        def fastbin_index(sz: int) -> int: ...


class GlibcHeapUnsortedBinsCommand(GenericCommand):
    def __init__(self) -> None: ...
    def do_invoke(self, *_: Any, **kwargs: Any) -> None: ...


class GlibcHeapSmallBinsCommand(GenericCommand):
    def __init__(self) -> None: ...
    def do_invoke(self, *_: Any, **kwargs: Any) -> None: ...


class GlibcHeapLargeBinsCommand(GenericCommand):
    def __init__(self) -> None: ...
    def do_invoke(self, *_: Any, **kwargs: Any) -> None: ...


class SolveKernelSymbolCommand(GenericCommand):
    def do_invoke(self, _: List[str], **kwargs: Any) -> None:
        def hex_to_int(num): ...


class DetailRegistersCommand(GenericCommand):
    def do_invoke(self, _: List[str], **kwargs: Any) -> None: ...


class ShellcodeCommand(GenericCommand):
    def __init__(self) -> None: ...
    def do_invoke(self, _: List[str]) -> None: ...


class ShellcodeSearchCommand(GenericCommand):
    def do_invoke(self, argv: List[str]) -> None: ...
    def search_shellcode(self, search_options: List) -> None: ...


class ShellcodeGetCommand(GenericCommand):
    def do_invoke(self, argv: List[str]) -> None: ...
    def get_shellcode(self, sid: int) -> None: ...


class RopperCommand(GenericCommand):
    def __init__(self) -> None: ...
    def pre_load(self) -> None: ...
    def do_invoke(self, argv: List[str]) -> None: ...


class AssembleCommand(GenericCommand):
    def __init__(self) -> None: ...
    def pre_load(self) -> None: ...
    def usage(self) -> None: ...
    def list_archs(self) -> None: ...
    def do_invoke(self, _: List[str], **kwargs: Any) -> None: ...


class ProcessListingCommand(GenericCommand):
    def __init__(self) -> None: ...
    def do_invoke(self, _: List, **kwargs: Any) -> None: ...
    def get_processes(self) -> Generator[Dict[str, str], None, None]: ...


class ElfInfoCommand(GenericCommand):
    def __init__(self) -> None: ...
    def do_invoke(self, _: List[str], **kwargs: Any) -> None: ...


class EntryPointBreakCommand(GenericCommand):
    def __init__(self) -> None: ...
    def do_invoke(self, argv: List[str]) -> None: ...
    def set_init_tbreak(self, addr: int) -> EntryBreakBreakpoint: ...
    def set_init_tbreak_pie(
        self, addr: int, argv: List[str]) -> EntryBreakBreakpoint: ...


class NamedBreakpointCommand(GenericCommand):
    def __init__(self) -> None: ...
    def do_invoke(self, _: List[str], **kwargs: Any) -> None: ...


class ContextCommand(GenericCommand):
    instruction_iterator: Callable
    def __init__(self) -> None: ...
    def post_load(self) -> None: ...
    def show_legend(self) -> None: ...
    def do_invoke(self, argv: List[str]) -> None: ...
    def context_title(self, m: Optional[str]) -> None: ...
    def context_regs(self) -> None: ...
    def context_stack(self) -> None: ...
    def addr_has_breakpoint(
        self, address: int, bp_locations: List[str]) -> bool: ...

    def context_code(self) -> None: ...
    def context_args(self) -> None: ...

    def print_arguments_from_symbol(
        self, function_name: str, symbol: "gdb.Symbol") -> None: ...

    def print_guessed_arguments(self, function_name: str) -> None:
        def __get_current_block_start_address() -> Optional[int]: ...

    def line_has_breakpoint(
        self, file_name: str, line_number: int, bp_locations: List[str]) -> bool: ...

    def context_source(self) -> None: ...
    def get_pc_context_info(self, pc: int, line: str) -> str: ...
    def context_trace(self) -> None: ...

    def context_threads(self) -> None:
        def reason() -> str: ...

    def context_additional_information(self) -> None: ...
    def context_memory(self) -> None: ...
    @classmethod
    def update_registers(cls, _) -> None: ...
    def empty_extra_messages(self, _) -> None: ...


class MemoryCommand(GenericCommand):
    def __init__(self) -> None: ...
    def do_invoke(self, argv: List[str]) -> None: ...


class MemoryWatchCommand(GenericCommand):
    def __init__(self) -> None: ...
    def do_invoke(self, argv: List[str]) -> None: ...


class MemoryUnwatchCommand(GenericCommand):
    def __init__(self) -> None: ...
    def do_invoke(self, argv: List[str]) -> None: ...


class MemoryWatchResetCommand(GenericCommand):
    def do_invoke(self, _: List[str]) -> None: ...


class MemoryWatchListCommand(GenericCommand):
    def do_invoke(self, _: List[str]) -> None: ...


class HexdumpCommand(GenericCommand):
    def __init__(self) -> None: ...
    def do_invoke(self, _: List[str], **kwargs: Any) -> None: ...
    def _hexdump(self, start_addr: int, length: int,
                 arrange_as: str, offset: int = 0) -> List[str]: ...


class HexdumpQwordCommand(HexdumpCommand):
    def __init__(self) -> None: ...


class HexdumpDwordCommand(HexdumpCommand):
    def __init__(self) -> None: ...


class HexdumpWordCommand(HexdumpCommand):
    def __init__(self) -> None: ...


class HexdumpByteCommand(HexdumpCommand):
    def __init__(self) -> None: ...


class PatchCommand(GenericCommand):
    def __init__(self) -> None: ...
    def do_invoke(self, _: List[str], **kwargs: Any) -> None: ...


class PatchQwordCommand(PatchCommand):
    def __init__(self) -> None: ...


class PatchDwordCommand(PatchCommand):
    def __init__(self) -> None: ...


class PatchWordCommand(PatchCommand):
    def __init__(self) -> None: ...


class PatchByteCommand(PatchCommand):
    def __init__(self) -> None: ...


class PatchStringCommand(GenericCommand):
    def do_invoke(self, argv: List[str]) -> None: ...


def dereference_from(addr: int) -> List[str]: ...


class DereferenceCommand(GenericCommand):
    def __init__(self) -> None: ...

    @staticmethod
    def pprint_dereferenced(addr: int, idx: int,
                            base_offset: int = 0) -> str: ...

    def do_invoke(self, _: List[str], **kwargs: Any) -> None: ...


class ASLRCommand(GenericCommand):
    def do_invoke(self, argv: List[str]) -> None: ...


class ResetCacheCommand(GenericCommand):
    def do_invoke(self, _: List[str]) -> None: ...


class VMMapCommand(GenericCommand):
    def do_invoke(self, argv: List[str]) -> None: ...
    def print_entry(self, entry: Section) -> None: ...
    def show_legend(self) -> None: ...
    def is_integer(self, n: str) -> bool: ...


class XFilesCommand(GenericCommand):
    def do_invoke(self, argv: List[str]) -> None: ...


class XAddressInfoCommand(GenericCommand):
    def __init__(self) -> None: ...
    def do_invoke(self, argv: List[str]) -> None: ...
    def infos(self, address: int) -> None: ...


class XorMemoryCommand(GenericCommand):
    def __init__(self) -> None: ...
    def do_invoke(self, _: List[str]) -> None: ...


class XorMemoryDisplayCommand(GenericCommand):
    def do_invoke(self, argv: List[str]) -> None: ...


class XorMemoryPatchCommand(GenericCommand):
    def do_invoke(self, argv: List[str]) -> None: ...


class TraceRunCommand(GenericCommand):
    def __init__(self) -> None: ...
    def do_invoke(self, argv: List[str]) -> None: ...
    def get_frames_size(self) -> int: ...
    def trace(self, loc_start: int, loc_end: int, depth: int) -> None: ...
    def start_tracing(self, loc_start: int, loc_end: int,
                      depth: int) -> None: ...


class PatternCommand(GenericCommand):
    def __init__(self) -> None: ...
    def do_invoke(self, _: List[str]) -> None: ...


class PatternCreateCommand(GenericCommand):
    def do_invoke(self, _: List[str], **kwargs: Any) -> None: ...


class PatternSearchCommand(GenericCommand):
    def do_invoke(self, _: List[str], **kwargs: Any) -> None: ...
    def search(self, pattern: str, size: int, period: int) -> None: ...


class ChecksecCommand(GenericCommand):
    def __init__(self) -> None: ...
    def do_invoke(self, argv: List[str]) -> None: ...
    def print_security_properties(self, filename: str) -> None: ...


class GotCommand(GenericCommand):
    def __init__(self): ...
    def get_jmp_slots(self, readelf: str, filename: str) -> List[str]: ...
    def do_invoke(self, argv: List[str]) -> None: ...


class HighlightCommand(GenericCommand):
    def __init__(self) -> None: ...
    def do_invoke(self, _: List[str]) -> None: ...


class HighlightListCommand(GenericCommand):
    def print_highlight_table(self) -> None: ...
    def do_invoke(self, _: List[str]) -> None: ...


class HighlightClearCommand(GenericCommand):
    def do_invoke(self, _: List[str]) -> None: ...


class HighlightAddCommand(GenericCommand):
    def do_invoke(self, argv: List[str]) -> None: ...


class HighlightRemoveCommand(GenericCommand):
    def do_invoke(self, argv: List[str]) -> None: ...


class FormatStringSearchCommand(GenericCommand):
    def do_invoke(self, _: List[str]) -> None: ...


class HeapAnalysisCommand(GenericCommand):
    def __init__(self) -> None: ...
    def do_invoke(self, argv: List[str]) -> None: ...
    def setup(self) -> None: ...
    def dump_tracked_allocations(self) -> None: ...
    def clean(self, _: gdb.Event) -> None: ...


class IsSyscallCommand(GenericCommand):
    def do_invoke(self, _: List[str]) -> None: ...


class SyscallArgsCommand(GenericCommand):
    def __init__(self) -> None: ...
    def do_invoke(self, _: List[str]) -> None: ...

    def __get_syscall_table(self, modname: str) -> Dict[str, Any]:
        def get_filepath(x: str) -> Optional[pathlib.Path]: ...
        def load_module(modname: str) -> Any: ...


def register_function(cls: Type["GenericFunction"]
                      ) -> Type["GenericFunction"]: ...


class GenericFunctionBase:
    def __init_subclass__(cls: Type["GenericFunctionBase"], **kwargs): ...


class GenericFunction(gdb.Function, GenericFunctionBase):
    def __init__(self) -> None: ...
    def invoke(self, *args: Any) -> int: ...
    def arg_to_long(self, args: List, index: int, default: int = 0) -> int: ...
    def do_invoke(self, args: Any) -> int: ...


class StackOffsetFunction(GenericFunction):
    def do_invoke(self, args: List) -> int: ...


class HeapBaseFunction(GenericFunction):
    def do_invoke(self, args: List) -> int: ...


class SectionBaseFunction(GenericFunction):
    def do_invoke(self, args: List) -> int: ...


class BssBaseFunction(GenericFunction):
    def do_invoke(self, args: List) -> int: ...


class GotBaseFunction(GenericFunction):
    def do_invoke(self, args: List) -> int: ...


class GefFunctionsCommand(GenericCommand):
    def __init__(self) -> None: ...
    def setup(self) -> None: ...
    def add_function_to_doc(self, function) -> None: ...
    def do_invoke(self, argv) -> None: ...


class GefCommand(gdb.Command):
    commands: Dict[str, GenericCommand]
    def __init__(self) -> None: ...
    def setup(self) -> None: ...
    def load_extra_plugins(self) -> int: ...
    def loaded_command_names(self) -> List[str]: ...
    def invoke(self, args: Any, from_tty: bool) -> None: ...

    def add_context_pane(self, pane_name: str, display_pane_function: Callable,
                         pane_title_function: Callable) -> None: ...

    def load(self, initial: bool = False) -> None:
        def is_loaded(x: str) -> bool: ...


class GefHelpCommand(gdb.Command):
    def __init__(self, commands: List[Tuple[str, Any, Any]]) -> None: ...
    def invoke(self, args: Any, from_tty: bool) -> None: ...

    def generate_help(
        self, commands: List[Tuple[str, Type[GenericCommand], Any]]) -> None: ...
    def add_command_to_doc(
        self, command: Tuple[str, Type[GenericCommand], Any]) -> None: ...

    def refresh(self) -> None: ...


class GefConfigCommand(gdb.Command):
    def __init__(self, loaded_commands: List[str]) -> None: ...
    def invoke(self, args: str, from_tty: bool) -> None: ...
    def print_setting(self, plugin_name: str,
                      verbose: bool = False) -> None: ...

    def print_settings(self) -> None: ...
    def set_setting(self, argv: Tuple[str, Any]) -> None: ...
    def complete(self, text: str, word: str) -> List[str]: ...


class GefSaveCommand(gdb.Command):
    def __init__(self) -> None: ...
    def invoke(self, args: Any, from_tty: bool) -> None: ...


class GefRestoreCommand(gdb.Command):
    def __init__(self) -> None: ...
    def invoke(self, args: str, from_tty: bool) -> None: ...


class GefMissingCommand(gdb.Command):
    def __init__(self) -> None: ...
    def invoke(self, args: Any, from_tty: bool) -> None: ...


class GefSetCommand(gdb.Command):
    def __init__(self) -> None: ...
    def invoke(self, args: Any, from_tty: bool) -> None: ...


class GefRunCommand(gdb.Command):
    def __init__(self) -> None: ...
    def invoke(self, args: Any, from_tty: bool) -> None: ...


class GefAlias(gdb.Command):
    def __init__(self, alias: str, command: str, completer_class: int = gdb.COMPLETE_NONE,
                 command_class: int = gdb.COMMAND_NONE) -> None: ...

    def invoke(self, args: Any, from_tty: bool) -> None: ...
    def lookup_command(self, cmd: str) -> Optional[Tuple[str, Type, Any]]: ...


class AliasesCommand(GenericCommand):
    def __init__(self) -> None: ...
    def do_invoke(self, _: List[str]) -> None: ...


class AliasesAddCommand(AliasesCommand):
    def __init__(self) -> None: ...
    def do_invoke(self, argv: List[str]) -> None: ...


class AliasesRmCommand(AliasesCommand):
    def __init__(self) -> None: ...
    def do_invoke(self, argv: List[str]) -> None: ...


class AliasesListCommand(AliasesCommand):
    def __init__(self) -> None: ...
    def do_invoke(self, _: List[str]) -> None: ...


class GefTmuxSetup(gdb.Command):
    def __init__(self) -> None: ...
    def invoke(self, args: Any, from_tty: bool) -> None: ...
    def tmux_setup(self) -> None: ...
    def screen_setup(self) -> None: ...


class GefInstallExtraScriptCommand(gdb.Command):
    def __init__(self) -> None: ...
    def invoke(self, args: str, from_tty: bool) -> None: ...
    def __install_extras_script(self, script: str) -> bool: ...


def __gef_prompt__(current_prompt: Any) -> str: ...


class GefManager(metaclass=abc.ABCMeta):
    def reset_caches(self) -> None: ...


class GefMemoryManager(GefManager):
    def __init__(self) -> None: ...
    def reset_caches(self) -> None: ...
    def write(self, address: int, buffer: ByteString,
              length: int = 0x10) -> None: ...

    def read(self, addr: int, length: int = 0x10) -> bytes: ...
    def read_integer(self, addr: int) -> int: ...
    def read_ascii_string(self, address: int) -> Optional[str]: ...
    def read_cstring(self, address: int, max_length: int = ...,
                     encoding: Optional[str] = None) -> str: ...

    @property
    def maps(self) -> List[Section]: ...
    def __parse_maps(self) -> List[Section]: ...

    def __parse_procfs_maps(self) -> Generator[Section, None, None]:
        def open_file(path: str, use_cache: bool = False) -> IO: ...

    def __parse_gdb_info_sections(self) -> Generator[Section, None, None]: ...


class GefHeapManager(GefManager):
    def __init__(self) -> None: ...
    def reset_caches(self) -> None: ...
    @property
    def main_arena(self) -> Optional[GlibcArena]: ...
    @property
    def selected_arena(self) -> Optional[GlibcArena]: ...
    @selected_arena.setter
    def selected_arena(self, value: GlibcArena) -> None: ...
    @property
    def arenas(self) -> Union[List, Iterator[GlibcArena]]: ...
    @property
    def base_address(self) -> Optional[int]: ...
    @property
    def chunks(self) -> Union[List[GlibcChunk], Iterator[GlibcChunk]]: ...
    def min_chunk_size(self) -> int: ...
    def malloc_alignment(self) -> int: ...
    def csize2tidx(self, size: int) -> int: ...
    def tidx2size(self, idx: int) -> int: ...
    def malloc_align_address(self, address: int) -> int: ...


class GefSetting:
    def __init__(self, value: Any,
                 cls: Optional[type] = None, description: Optional[str] = None, hooks: Optional[Dict[str, Callable]] = None) -> None: ...


class GefSettingsManager(dict):
    def __getitem__(self, name: str) -> Any: ...
    def __setitem__(self, name: str, value: Any) -> None: ...
    def __delitem__(self, name: str) -> None: ...
    def raw_entry(self, name: str) -> GefSetting: ...


class GefSessionManager(GefManager):
    remote: Optional[bool] = ...
    qemu_mode: bool = ...
    convenience_vars_index: int = ...
    heap_allocated_chunks: List[Tuple[int, int]] = ...
    heap_freed_chunks: List[Tuple[int, int]] = ...
    heap_uaf_watchpoints: List[UafWatchpoint] = ...
    pie_breakpoints: Dict[int, PieVirtualBreakpoint] = ...
    pie_counter: int = ...
    aliases: List[GefAlias] = ...
    modules: List[Elf] = ...
    constants: Dict[str, pathlib.Path] = ...
    def __init__(self) -> None: ...
    def reset_caches(self) -> None: ...
    @property
    def auxiliary_vector(self) -> Optional[Dict[str, int]]: ...
    @property
    def os(self) -> str: ...
    @property
    def pid(self) -> int: ...
    @property
    def file(self) -> pathlib.Path: ...
    @property
    def pagesize(self) -> int: ...
    @property
    def canary(self) -> Optional[Tuple[int, int]]: ...


class GefUiManager(GefManager):
    redirect_fd: Optional[TextIOWrapper] = ...
    context_hidden: bool
    stream_buffer: Optional[StringIO] = ...
    highlight_table: Dict[str, str] = ...
    libc_args_table: Dict[str, Dict[str, Dict[str, str]]] = ...
    watches: Dict[int, Tuple[int, str]] = ...
    context_messages: List[str] = ...
    def __init__(self) -> None: ...


class GefLibcManager(GefManager):
    def __init__(self) -> None: ...
    @property
    def version(self) -> Optional[Tuple[int, int]]: ...


class Gef:
    binary: Optional[Elf] = ...
    arch: Architecture = ...
    config: GefSettingsManager = ...
    ui: GefUiManager = ...
    libc: GefLibcManager = ...
    memory: GefMemoryManager = ...
    heap: GefHeapManager = ...
    session: GefSessionManager = ...
    gdb: GefCommand = ...
    def __init__(self) -> None: ...
    def reinitialize_managers(self) -> None: ...
    def setup(self) -> None: ...
    def reset_caches(self) -> None: ...


gef: Gef = ...
